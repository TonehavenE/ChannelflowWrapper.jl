"""
The ChannelflowWrapper.jl module is designed to provide convenient wrappers around commonly used Channelflow (the C++ library) functionality.
"""
module ChannelflowWrapper

export projectfield, field2coeff, coeff2field, changegrid, findsoln, continuesoln, findeigenvals, edgetracking, simulateflow, fieldprops, randomfield, plotfield, L2op, L2norm, diffop, perturbfield, addfields, addbaseflow, findsymmetries

import Channelflow_jll

include("utilities.jl")
"""
    field2coeff(ijklfile, source, output; kwargs...)

`field2coeff` takes a `source` (full velocity field) and projects it onto the
ODE basis defined by `ijklfile`, storing the resulting coefficient vector in `output`.

In addition to writing to the `output` file, this returns the vector of ODE coefficients.
This calls the Channelflow binary `projectfield` in its default mode.

# Arguments
- `ijklfile::AbstractString`: The file path to the file specifying the ijkl basis.
- `source::AbstractString`: The file path to the input velocity field to be projected.
- `output_base::AbstractString`: The file path to store the output coefficient vector. 
                                 `.asc` is appended to this if it doesn't already end with it.

# Keyword Arguments
- `nrm::Bool`: Normalize basis elements.
- `sb::Bool`: Output basis elements as flowfields.
- `sIP::Bool`: Output the inner product matrix.
- `pb::Bool`: Save slices of basis elements for plotting.
- `pn::Bool`: Print L2Norm(psi[n]), L2Norm(div(u)), etc.
- `o::String`: Directory for basis plots (default: "plots/").
- `A::String`: File path to load inner product matrix from.
"""
function field2coeff(
    ijklfile::AbstractString,
    source::AbstractString,
    output_base::AbstractString;
    workdir::AbstractString=".",
    kwargs...
)
    verify_file(ijklfile)
    verify_file(source)
    mkpath(workdir)
    output_target = occursin(".asc", output_base) ? output_base : output_base * ".asc"
    output_target = abspath(output_target)
    tag = string(time_ns())
    output_working = "pf_" * tag * ".asc"
    intermediate_working = joinpath(workdir, "x" * output_working)
    junk_working = joinpath(workdir, "u" * output_working)

    flags = kwargs_to_flags(kwargs)

    cmd = Cmd(
        `$(Channelflow_jll.projectfield()) $flags $(abspath(ijklfile)) $(abspath(source)) $output_working`;
        dir=workdir
    )
    run(cmd)

    # Check if the intermediate file (which has the coefficients) exists before trying to move it
    if isfile(intermediate_working)
        mv(intermediate_working, output_target; force=true)
    else
        error("Channelflow binary failed to produce the intermediate coefficient file: $intermediate_working")
    end

    # Remove the junk file generated by the binary, if it exists
    if isfile(junk_working)
        rm(junk_working)
    end

    return myreaddlm(output_target)
end

"""
    field2coeff(ijkl::AbstractMatrix, source, output; kwargs...)

Converts a field to the coefficient basis described by `ijkl`, where `ijkl` is a
Julia matrix rather than a file.
"""
function field2coeff(
    ijkl::AbstractMatrix,
    source::AbstractString,
    output::AbstractString;
    workdir::AbstractString=".",
    kwargs...
)
    mkpath(workdir)
    tag = string(time_ns())
    ijkl_path = joinpath(workdir, "temp_ijkl_" * tag * ".asc")
    ijkl2file(ijkl, ijkl_path)
    coeffs = field2coeff(ijkl_path, source, output; workdir=workdir, kwargs...)
    rm(ijkl_path)
    return coeffs
end

"""
    coeff2field(source_coeffs, ijklfile, field_example, output; kwargs...)

Converts a file containing ODE coefficients (`source_coeffs`) back into a full
velocity field (`output`), using `field_example` as a grid template.

This calls the Channelflow binary `projectfield` with the `-x` flag.

# Arguments
- `source_coeffs::AbstractString`: File path to the vector of ODE coefficients.
- `ijklfile::AbstractString`: File path to the file specifying the ijkl basis.
- `field_example::AbstractString`: File path to a velocity field to use as a template
                                 (for grid size, box length, etc.).
- `output::AbstractString`: The file path to store the reconstructed output velocity field.

# Keyword Arguments
- All flags from `field2coeff` are also valid here, e.g., `nrm=true`
"""
function coeff2field(
    source_coeffs::AbstractString,
    ijklfile::AbstractString,
    field_example::AbstractString,
    output::AbstractString;
    workdir::AbstractString=".",
    kwargs...
)
    verify_file(source_coeffs)
    verify_file(ijklfile)
    verify_file(field_example)

    mkpath(workdir)
    output_target = occursin(".nc", output) ? output : output * ".nc"
    output_target = abspath(output_target)
    tag = string(time_ns())
    output_working = "pf_" * tag * ".nc"
    flags = kwargs_to_flags(kwargs)
    cmd = Cmd(
        `$(Channelflow_jll.projectfield()) $flags -x $(abspath(source_coeffs)) $(abspath(ijklfile)) $(abspath(field_example)) $output_working`;
        dir=workdir
    )
    run(cmd)

    working_file = joinpath(workdir, "u" * output_working)

    if isfile(working_file)
        mv(working_file, output_target; force=true)
    else
        error("Channelflow binary failed to reconstruct the field. Expected file: $working_file")
    end
end

"""
    coeff2field(x, ijkl, field_example, output; kwargs...)

Converts a coefficient vector `x` and `ijkl` matrix directly, without needing to
store them in files. The result is stored in a file at `output`.
"""
function coeff2field(
    x::AbstractVector,
    ijkl::AbstractMatrix,
    field_example::AbstractString,
    output::AbstractString;
    workdir::AbstractString=".",
    kwargs...
)
    mkpath(workdir)
    tag = string(time_ns())
    ijkl_path = joinpath(workdir, "temp_ijkl_" * tag * ".asc")
    x_path = joinpath(workdir, "temp_x_" * tag * ".asc")
    ijkl2file(ijkl, ijkl_path)
    save(x, x_path)

    coeff2field(x_path, ijkl_path, field_example, output; workdir=workdir, kwargs...)

    rm(ijkl_path)
    rm(x_path)
end

"""
    projectfield(ijklfile, source, target; flags)

Legacy interface, defer to `field2coeff` ideally.
"""
function projectfield(ijklfile, source, target; workdir::AbstractString=".", kwargs...)
    field2coeff(ijklfile, source, target; workdir=workdir, kwargs=kwargs)
end

"""
    projectfield(source_coeffs, ijklfile, field_example, output; flags)

Legacy interface, defer to `coeff2field` ideally.
"""
function projectfield(source_coeffs, ijklfile, field_example, output; workdir::AbstractString=".", kwargs...)
    coeff2field(source_coeffs, ijklfile, field_example, output; workdir=workdir, kwargs=kwargs)
end


"""
    findsoln(guess_flowfield::AbstractString; kwargs...)

Takes the flowfield stored at filepath `guess_flowfield` and attempts to find a
solution (e.g., equilibrium, traveling wave, periodic orbit) using a Newton-Krylov solver.

This is a Julia wrapper for the Channelflow binary `findsoln`.

# Arguments
- `guess_flowfield::AbstractString`: The file path to the initial guess flow field.

# Keyword Arguments
All command-line flags for the `findsoln` binary are passed to this function as keywords.
- Boolean switches (e.g., `-eqb`) are passed as `eqb=true`.
- Value flags (e.g., `-R 350`) are passed as `R=350`.
- String flags (e.g., `-solver gmres`) are passed as `solver="gmres"`.

See the `findsoln --help` output for a complete list.

## Common Keyword Examples

### Search Type:
- `eqb::Bool`: Search for a fixed point (equilibrium) or traveling wave.
- `orb::Bool`: Search for a periodic or relative periodic orbit.
- `xrel::Bool`: Search for a relative solution (TW or RPO) with shift in x.
- `zrel::Bool`: Search for a relative solution (TW or RPO) with shift in z.

### System Parameters:
- `R::Real`: Pseudo-Reynolds number (default: 400).
- `nu::Real`: Kinematic viscosity (overrides `R`).
- `symms::String`: Path to a file listing symmetry generators.
- `sigma::String`: Path to a file for the `sigma` matrix (for TWs/RPOs).

### Numerical/Solver Parameters:
- `T::Real`: Final time of integration or period of map (default: 20).
- `dt::Real`: Timestep (default: 0.03125).
- `solver::String`: "gmres", "fgmres", "eigen", "bicgstab".
- `opt::String`: "hookstep", "linear", "none".
- `Nn::Int`: Max Newton steps (default: 20).
- `Ng::Int`: Max GMRES iterations (default: 500).
- `od::String`: Output directory (default: "./").

# Example Usage
```julia
# Find an equilibrium at Re=350 with symmetries from local file
findsoln("u_Re350.nc"; eqb=true, R=350, T=10, symms="./sxy_sz_txz.asc")

# Find a z-relative traveling wave
findsoln("u_guess.nc"; eqb=true, zrel=true, T=10, R=200, sigma="sigma_guess.asc", symms="sxytxz.asc")
```
"""
function findsoln(guess_flowfield::AbstractString; workdir::AbstractString=".", kwargs...)
    verify_file(guess_flowfield)
    flags = kwargs_to_flags(kwargs)
    cmd = Cmd(`$(Channelflow_jll.findsoln()) $flags $(abspath(guess_flowfield))`; dir=workdir)
    run(cmd)
end


"""
    changegrid(infield::AbstractString, outfield::AbstractString; kwargs...)

Interpolates a given flowfield onto a different grid.
This calls the Channelflow binary `changegrid`.

# Arguments
- `infield::AbstractString`: The file path to the input flow field.
- `outfield::AbstractString`: The file path to store the output (interpolated) flow field.

# Keyword Arguments
- `p::Bool` (default: true): Set padding modes to zero.
- `dv::Bool` (default: true): Fix divergence and Dirichlet BCs.
- `Nx::Int`: New number of x gridpoints.
- `Ny::Int`: New number of y gridpoints.
- `Nz::Int`: New number of z gridpoints.
- `a::Real`: New lower wall position.
- `b::Real`: New upper wall position.
- `al::Real` or `alpha::Real`: New alpha (2pi/Lx).
- `ga::Real` or `gamma::Real`: New gamma (2pi/Lz).
- `lx::Real`: New Lx = 2 pi lx.
- `lz::Real`: New Lz = 2 pi lz.
- `Lx::Real`: Streamwise (x) box length.
- `Lz::Real`: Spanwise (z) box length.
- `np0::Int` or `nproc0::Int`: Number of MPI-processes for transpose.
- `np1::Int` or `nproc1::Int`: Number of MPI-processes for one fft.
"""
function changegrid(infield::AbstractString, outfield::AbstractString; workdir::AbstractString=".", kwargs...)
    verify_file(infield)
    flags = kwargs_to_flags(kwargs)
    cmd = Cmd(`$(Channelflow_jll.changegrid()) $flags $(abspath(infield)) $(abspath(outfield))`; dir=workdir)
    run(cmd)
end

"""
    continuesoln(initial_flowfield::AbstractString; kwargs...)

Performs a parametric continuation of an invariant solution (e.g., equilibrium,
traveling wave, or periodic orbit) starting from an initial guess.

This is a Julia wrapper for the Channelflow binary `continuesoln`.

# Arguments
- `initial_flowfield::AbstractString`: The file path to the initial solution
  (e.g., "ueqd_Re400.nc") from which to start the continuation.

# Keyword Arguments
All command-line flags for the `continuesoln` binary are passed as keywords.
- Boolean switches (e.g., `-eqb`) are passed as `eqb=true`.
- Value flags (e.g., `-R 400`) are passed as `R=400`.
- String flags (e.g., `-cont Re`) are passed as `cont="Re"`.

See `continuesoln --help` for the full list of ~70 options.

## Key Keyword Arguments
- `cont::String`: **(Required)** The continuation parameter. One of:
  "Re", "P", "Ub", "Uw", "ReP", "Theta", "ThLx", "ThLz", "Lx", "Lz",
  "Aspect", "Diag", "Lt", "Vs", "ReVs", "H", "HVs", "Rot".
- `dmu::Real`: The initial relative increment for the continuation parameter
  (default: 0.0001).
- `eqb::Bool` or `orb::Bool`: Specify the solution type (equilibrium or orbit).
- `R::Real`: The initial pseudo-Reynolds number (default: 400).
- `symms::String`: Path to a file listing symmetry generators.
- `al::Bool`: Use arclength continuation (default: false).
- `ds0::Real`: Initial arclength increment (if `al=true`).
- `targ::Bool`: Abort when the target value `targMu` is reached.
- `targMu::Real`: The target value for the continuation parameter.
- `od::String`: Output directory (default: "./").

# Example Usage
```julia
# Continue an equilibrium in Reynolds number
continuesoln("ueqd_Re400.nc";
    cont="Re",
    eqb=true,
    R=400,
    T=19,
    dmu=-0.01,
    symms="sxy_sztx.asc"
)
```
"""
function continuesoln(initial_flowfield::AbstractString; workdir::AbstractString=".", kwargs...)
    verify_file(initial_flowfield)
    flags = kwargs_to_flags(kwargs)
    cmd = Cmd(`$(Channelflow_jll.continuesoln()) $flags $(abspath(initial_flowfield))`; dir=workdir)
    run(cmd)
end

const _FINDEIGENVALS_FLAG_MAP = Dict{Symbol, String}(
    # System parameters
    :R => "-R",
    :Reynolds => "--Reynolds",
    :nu => "-nu",

    # Boundary conditions
    :bf => "-bf",
    :baseflow => "--baseflow",
    :mc => "-mc",
    :meanconstraint => "--meanconstraint",
    :dPds => "-dPds",
    :Ubulk => "-Ubulk",
    :Uwall => "-Uwall",
    :theta => "-theta",
    :Vs => "-Vs",
    :Vsuck => "--Vsuck",
    :rot => "-rot",
    :rotation => "--rotation",

    # Numerical setup
    :da => "-da",
    :dealiasing => "--dealiasing",
    :T0 => "-T0",
    :T => "-T",
    :T1 => "--T1",
    :dT => "-dT",
    :dt => "-dt",
    :vdt => "-vdt",
    :variabledt => "--variabledt",
    :dtmin => "-dtmin",
    :dtmax => "-dtmax",
    :CFLmin => "-CFLmin",
    :CFLmax => "-CFLmax",
    :ts => "-ts",
    :timestepping => "--timestepping",
    :is => "-is",
    :initstepping => "--initstepping",
    :nl => "-nl",
    :nonlinearity => "--nonlinearity",
    :symmpi => "-symmpi",
    :symmetryprojection => "--symmetryprojection",
    :symms => "-symms",
    :symmetries => "--symmetries",

    # Arnoldi options
    :isnorm => "-isnorm",
    :isnormal => "--isnormal",
    :N => "-N",
    :Narnoldi => "--Narnoldi",
    :Ns => "-Ns",
    :Nstable => "--Nstable",
    :fNs => "-fNs",
    :fixedNsave => "--fixedNsave",
    :ek => "-ek",
    :epsKrylov => "--epsKrylov",
    :cd => "-cd",
    :centerdiff => "--centerdiff",
    :oc => "-oc",
    :orthocheck => "--orthocheck",
    :o => "-o",
    :outdir => "--outdir",
    :est => "-est",
    :epsStability => "--epsStability",

    # Program options
    :poinc => "-poinc",
    :poincare => "--poincare",
    :sigma => "-sigma",
    :sd => "-sd",
    :seed => "--seed",
    :s => "-s",
    :smoothness => "--smoothness",
    :edu => "-edu",
    :epsdu => "--epsdu",
    :du => "-du",
    :perturb => "--perturb",
    :np0 => "-np0",
    :nproc0 => "--nproc0",
    :np1 => "-np1",
    :nproc1 => "--nproc1",
)

const _FINDEIGENVALS_BOOL_VALUE_FLAGS = Set([
    :vdt, :variabledt,
])

function _findeigenvals_flag_for_key(key::Symbol)
    haskey(_FINDEIGENVALS_FLAG_MAP, key) && return _FINDEIGENVALS_FLAG_MAP[key]
    throw(ArgumentError("Unknown findeigenvals option keyword: $(key)"))
end

function _findeigenvals_kwargs_to_flags(kwargs)
    flags = String[]
    for (key, value) in kwargs
        flag_name = _findeigenvals_flag_for_key(key)
        if (key in _FINDEIGENVALS_BOOL_VALUE_FLAGS) && (value isa Bool)
            push!(flags, flag_name, lowercase(string(value)))
        elseif value isa Bool
            value && push!(flags, flag_name)
        else
            push!(flags, flag_name, string(value))
        end
    end
    return flags
end

"""
    findeigenvals(flowfield::AbstractString; kwargs...)

Computes the spectrum of eigenvalues of equilibria, traveling waves, or periodic
orbits using Arnoldi iteration.

This is a Julia wrapper for the Channelflow binary `findeigenvals`.

# Arguments
- `flowfield::AbstractString`: Input EQB/TW/PO solution field.

# Keyword Arguments
All command-line options are passed via keywords.

Common groups include:
- System/boundary/numerics: `R`, `nu`, `bf`, `T`, `dt`, `vdt`, `symms`, ...
- Arnoldi: `N`, `Ns`, `isnorm`, `fNs`, `ek`, `cd`, `oc`, `o`, `est`
- Program: `poinc`, `sigma`, `sd`, `s`, `edu`, `du`, `np0`, `np1`
"""
function findeigenvals(flowfield::AbstractString; kwargs...)
    verify_file(flowfield)
    flags = _findeigenvals_kwargs_to_flags(kwargs)
    run(`$(Channelflow_jll.findeigenvals()) $flags $flowfield`)
end

const _EDGETRACKING_FLAG_MAP = Dict{Symbol, String}(
    # System parameters
    :R => "-R",
    :Reynolds => "--Reynolds",
    :nu => "-nu",

    # Boundary conditions
    :bf => "-bf",
    :baseflow => "--baseflow",
    :mc => "-mc",
    :meanconstraint => "--meanconstraint",
    :dPds => "-dPds",
    :Ubulk => "-Ubulk",
    :Uwall => "-Uwall",
    :theta => "-theta",
    :Vs => "-Vs",
    :Vsuck => "--Vsuck",
    :rot => "-rot",
    :rotation => "--rotation",

    # Numerical setup
    :da => "-da",
    :dealiasing => "--dealiasing",
    :T0 => "-T0",
    :T => "-T",
    :T1 => "--T1",
    :dT => "-dT",
    :dt => "-dt",
    :vdt => "-vdt",
    :variabledt => "--variabledt",
    :dtmin => "-dtmin",
    :dtmax => "-dtmax",
    :CFLmin => "-CFLmin",
    :CFLmax => "-CFLmax",
    :ts => "-ts",
    :timestepping => "--timestepping",
    :is => "-is",
    :initstepping => "--initstepping",
    :nl => "-nl",
    :nonlinearity => "--nonlinearity",
    :symmpi => "-symmpi",
    :symmetryprojection => "--symmetryprojection",
    :symms => "-symms",
    :symmetries => "--symmetries",

    # Program options
    :c => "-c",
    :cont => "--continue",
    :continue_ => "--continue",
    :EcfH => "-EcfH",
    :EcfHigh => "--EcfHigh",
    :EcfL => "-EcfL",
    :EcfLow => "--EcfLow",
    :L2H => "-L2H",
    :L2High => "--L2High",
    :L2L => "-L2L",
    :L2Low => "--L2Low",
    :n2h => "-n2h",
    :normToHeight => "--normToHeight",
    :maxDcy => "-maxDcy",
    :tMaxDecay => "--tMaxDecay",
    :tMaxAtt => "-tMaxAtt",
    :tMaxAttractor => "--tMaxAttractor",
    :tMinAtt => "-tMinAtt",
    :tMinAttractor => "--tMinAttractor",
    :epsA => "-epsA",
    :epsilonAdvance => "--epsilonAdvance",
    :epsB => "-epsB",
    :epsilonBisection => "--epsilonBisection",
    :nBis => "-nBis",
    :nBisecTrajectories => "--nBisecTrajectories",
    :cLH => "-cLH",
    :chooseLHfirst => "--chooseLHfirst",
    :lS => "-lS",
    :lambdaStep => "--lambdaStep",
    :lH => "-lH",
    :lambdaH => "--lambdaH",
    :lL => "-lL",
    :lambdaL => "--lambdaL",
    :keepUL => "-keepUL",
    :vrfyLH => "-vrfyLH",
    :verifyLH => "--verifyLH",
    :s => "-s",
    :saveInterval => "--saveInterval",
    :saveUL => "-saveUL",
    :saveUH => "-saveUH",
    :saveMin => "-saveMin",
    :saveMinima => "--saveMinima",
    :np0 => "-np0",
    :nproc0 => "--nproc0",
    :np1 => "-np1",
    :nproc1 => "--nproc1",
    :log => "-log",
    :logfile => "--logfile",
    :sd => "-sd",
    :savedir => "--savedir",
)

const _EDGETRACKING_BOOL_VALUE_FLAGS = Set([
    :vdt, :variabledt,
    :saveUL, :saveUH, :saveMin, :saveMinima,
])

function _edgetracking_flag_for_key(key::Symbol)
    haskey(_EDGETRACKING_FLAG_MAP, key) && return _EDGETRACKING_FLAG_MAP[key]
    throw(ArgumentError("Unknown edgetracking option keyword: $(key)"))
end

function _edgetracking_kwargs_to_flags(kwargs)
    flags = String[]
    for (key, value) in kwargs
        flag_name = _edgetracking_flag_for_key(key)
        if (key in _EDGETRACKING_BOOL_VALUE_FLAGS) && (value isa Bool)
            push!(flags, flag_name, lowercase(string(value)))
        elseif value isa Bool
            value && push!(flags, flag_name)
        else
            push!(flags, flag_name, string(value))
        end
    end
    return flags
end

"""
    edgetracking(initial_flowfield::AbstractString; kwargs...)

Runs edge tracking to locate edge states starting from an initial flowfield.

This is a Julia wrapper for the Channelflow binary `edgetracking`.

# Arguments
- `initial_flowfield::AbstractString`: Initial flow field.

# Keyword Arguments
All command-line options are passed via keywords.

Notes:
- Use `cont=true` (or `continue_=true`) for `--continue`.
- Bool-valued options like `saveUL`, `saveUH`, `saveMin` and `vdt` are emitted
  as explicit `true/false` values when provided as Bool.
"""
function edgetracking(initial_flowfield::AbstractString; kwargs...)
    verify_file(initial_flowfield)
    flags = _edgetracking_kwargs_to_flags(kwargs)
    run(`$(Channelflow_jll.edgetracking()) $flags $initial_flowfield`)
end

const _FIELDPROPS_FLAG_MAP = Dict{Symbol, String}(
    # Property/report options
    :g => "-g",
    :geometry => "--geometry",
    :m => "-m",
    :mean => "--mean",
    :n => "-n",
    :norm => "--norm",
    :sp => "-sp",
    :spectral => "--spectral",
    :sy => "-sy",
    :symmetry => "--symmetry",
    :d => "-d",
    :dynamic => "--dynamic",
    :mcs => "-mcs",
    :e => "-e",
    :energy => "--energy",
    :w => "-w",
    :wall => "--wall",
    :l => "-l",
    :local_ => "--local",
    :sup => "-sup",
    :saveUprofile => "--saveUprofile",
    :fst => "-fst",
    :fieldstats => "--fieldstats",
    :eps => "-eps",
    :dg => "-dg",
    :digits => "--digits",

    # System parameters
    :R => "-R",
    :Reynolds => "--Reynolds",
    :nu => "-nu",

    # Boundary conditions
    :bf => "-bf",
    :baseflow => "--baseflow",
    :mc => "-mc",
    :meanconstraint => "--meanconstraint",
    :dPds => "-dPds",
    :Ubulk => "-Ubulk",
    :Uwall => "-Uwall",
    :theta => "-theta",
    :Vs => "-Vs",
    :Vsuck => "--Vsuck",
    :rot => "-rot",
    :rotation => "--rotation",
    :ub => "-ub",
    :Ubase => "--Ubase",
    :wb => "-wb",
    :Wbase => "--Wbase",
    :Uf => "-Uf",
    :Tint => "-Tint",

    # Numerical setup
    :da => "-da",
    :dealiasing => "--dealiasing",
    :T0 => "-T0",
    :T => "-T",
    :T1 => "--T1",
    :dT => "-dT",
    :dt => "-dt",
    :vdt => "-vdt",
    :variabledt => "--variabledt",
    :dtmin => "-dtmin",
    :dtmax => "-dtmax",
    :CFLmin => "-CFLmin",
    :CFLmax => "-CFLmax",
    :ts => "-ts",
    :timestepping => "--timestepping",
    :is => "-is",
    :initstepping => "--initstepping",
    :nl => "-nl",
    :nonlinearity => "--nonlinearity",
    :symmpi => "-symmpi",
    :symmetryprojection => "--symmetryprojection",
    :symms => "-symms",
    :symmetries => "--symmetries",
)

const _FIELDPROPS_BOOL_VALUE_FLAGS = Set([
    :vdt, :variabledt,
])

function _fieldprops_flag_for_key(key::Symbol)
    haskey(_FIELDPROPS_FLAG_MAP, key) && return _FIELDPROPS_FLAG_MAP[key]
    throw(ArgumentError("Unknown fieldprops option keyword: $(key)"))
end

function _fieldprops_kwargs_to_flags(kwargs)
    flags = String[]
    for (key, value) in kwargs
        flag_name = _fieldprops_flag_for_key(key)
        if (key in _FIELDPROPS_BOOL_VALUE_FLAGS) && (value isa Bool)
            push!(flags, flag_name, lowercase(string(value)))
        elseif value isa Bool
            value && push!(flags, flag_name)
        else
            push!(flags, flag_name, string(value))
        end
    end
    return flags
end

"""
    fieldprops(flowfield::AbstractString; kwargs...)

Prints information and diagnostics for a `FlowField`.

This is a Julia wrapper for the Channelflow binary `fieldprops`.

# Arguments
- `flowfield::AbstractString`: Input flow field.

# Keyword Arguments
All command-line options are passed via keywords, including:
- Property options: `g`, `m`, `n`, `sp`, `sy`, `d`, `mcs`, `e`, `w`, `l`,
  `sup`, `fst`, `eps`, `dg`.
- System/baseflow/numerics options: `R`, `nu`, `bf`, `Ubulk`, `ub`, `wb`,
  `Uf`, `Tint`, `T`, `dt`, `vdt`, `symms`, etc.
"""
function fieldprops(flowfield::AbstractString; kwargs...)
    verify_file(flowfield)
    flags = _fieldprops_kwargs_to_flags(kwargs)
    run(`$(Channelflow_jll.fieldprops()) $flags $flowfield`)
end

const _RANDOMFIELD_FLAG_MAP = Dict{Symbol, String}(
    :Nx => "-Nx",
    :Ny => "-Ny",
    :Nz => "-Nz",
    :a => "-a",
    :alpha => "--alpha",
    :g => "-g",
    :gamma => "--gamma",
    :lx => "-lx",
    :lz => "-lz",
    :Lx => "-Lx",
    :Lz => "-Lz",
    :ymin => "-ymin",
    :ymax => "-ymax",
    :sd => "-sd",
    :seed => "--seed",
    :s => "-s",
    :smoothness => "--smoothness",
    :m => "-m",
    :magnitude => "--magnitude",
    :mf => "-mf",
    :meanflow => "--meanflow",
    :symms => "-symms",
    :symmetries => "--symmetries",
)

function _randomfield_flag_for_key(key::Symbol)
    haskey(_RANDOMFIELD_FLAG_MAP, key) && return _RANDOMFIELD_FLAG_MAP[key]
    throw(ArgumentError("Unknown randomfield option keyword: $(key)"))
end

function _randomfield_kwargs_to_flags(kwargs)
    flags = String[]
    for (key, value) in kwargs
        flag_name = _randomfield_flag_for_key(key)
        if value isa Bool
            value && push!(flags, flag_name)
        else
            push!(flags, flag_name, string(value))
        end
    end
    return flags
end

"""
    randomfield(outfield::AbstractString; kwargs...)

Constructs a random divergence-free field with Dirichlet boundary conditions and
writes it to `outfield`.

This is a Julia wrapper for the Channelflow binary `randomfield`.

# Arguments
- `outfield::AbstractString`: Output field filename.

# Keyword Arguments
All command-line options are passed via keywords, including:
- Grid/geometry: `Nx`, `Ny`, `Nz`, `a`, `g`, `lx`, `lz`, `Lx`, `Lz`, `ymin`, `ymax`
- Randomization: `sd`, `s`, `m`, `mf`
- Symmetry constraints: `symms`
"""
function randomfield(outfield::AbstractString; kwargs...)
    flags = _randomfield_kwargs_to_flags(kwargs)
    run(`$(Channelflow_jll.randomfield()) $flags $outfield`)
end

const _SIMULATEFLOW_FLAG_MAP = Dict{Symbol, String}(
    # System parameters
    :R => "-R",
    :Reynolds => "--Reynolds",
    :nu => "-nu",

    # Boundary conditions
    :bf => "-bf",
    :baseflow => "--baseflow",
    :mc => "-mc",
    :meanconstraint => "--meanconstraint",
    :dPds => "-dPds",
    :Ubulk => "-Ubulk",
    :Uwall => "-Uwall",
    :theta => "-theta",
    :Vs => "-Vs",
    :Vsuck => "--Vsuck",
    :rot => "-rot",
    :rotation => "--rotation",

    # Numerical setup
    :da => "-da",
    :dealiasing => "--dealiasing",
    :T0 => "-T0",
    :T => "-T",
    :T1 => "--T1",
    :dT => "-dT",
    :dt => "-dt",
    :vdt => "-vdt",
    :variabledt => "--variabledt",
    :dtmin => "-dtmin",
    :dtmax => "-dtmax",
    :CFLmin => "-CFLmin",
    :CFLmax => "-CFLmax",
    :ts => "-ts",
    :timestepping => "--timestepping",
    :is => "-is",
    :initstepping => "--initstepping",
    :nl => "-nl",
    :nonlinearity => "--nonlinearity",
    :symmpi => "-symmpi",
    :symmetryprojection => "--symmetryprojection",
    :symms => "-symms",
    :symmetries => "--symmetries",

    # Program options
    :o => "-o",
    :outdir => "--outdir",
    :l => "-l",
    :label => "--label",
    :sp => "-sp",
    :savepressure => "--savepressure",
    :cfl => "-cfl",
    :l2 => "-l2",
    :l2norm => "--l2norm",
    :ch => "-ch",
    :chebyNorm => "--chebyNorm",
    :D => "-D",
    :dissipation => "--dissipation",
    :I => "-I",
    :input => "--input",
    :dv => "-dv",
    :divergence => "--divergence",
    :u => "-u",
    :ubulk => "--ubulk",
    :Up => "-Up",
    :Ubulk_print => "--Ubulk-print",
    :p => "-p",
    :pressure => "--pressure",
    :e => "-e",
    :ecfmin => "--ecfmin",
    :umin => "--umin",
    :s => "-s",
    :saveinterval => "--saveinterval",
    :np0 => "-np0",
    :nproc0 => "--nproc0",
    :np1 => "-np1",
    :nproc1 => "--nproc1",
)

const _SIMULATEFLOW_BOOL_VALUE_FLAGS = Set([
    :vdt, :variabledt, :ch, :chebyNorm,
])

function _simulateflow_flag_for_key(key::Symbol)
    haskey(_SIMULATEFLOW_FLAG_MAP, key) && return _SIMULATEFLOW_FLAG_MAP[key]
    throw(ArgumentError("Unknown simulateflow option keyword: $(key)"))
end

function _simulateflow_kwargs_to_flags(kwargs)
    flags = String[]
    for (key, value) in kwargs
        flag_name = _simulateflow_flag_for_key(key)
        if (key in _SIMULATEFLOW_BOOL_VALUE_FLAGS) && (value isa Bool)
            # simulateflow expects an explicit bool value for these options.
            push!(flags, flag_name, lowercase(string(value)))
        elseif value isa Bool
            value && push!(flags, flag_name)
        else
            push!(flags, flag_name, string(value))
        end
    end
    return flags
end

"""
    simulateflow(initial_flowfield::AbstractString; kwargs...)

Integrates plane Couette or channel flow from a given initial condition and
saves velocity fields to disk.

This is a Julia wrapper for the Channelflow binary `simulateflow`.

# Arguments
- `initial_flowfield::AbstractString`: File path to the input initial condition.

# Keyword Arguments
All command-line options are passed via keywords.

## Common Option Groups
- System: `R`, `nu`
- Boundary/baseflow: `bf`, `mc`, `dPds`, `Ubulk`, `Uwall`, `theta`, `Vs`, `rot`
- Time integration: `T0`, `T`, `dT`, `dt`, `vdt`, `dtmin`, `dtmax`, `CFLmin`, `CFLmax`, `ts`, `is`, `nl`
- Output and reporting: `outdir`, `label`, `sp`, `cfl`, `l2`, `ch`, `D`, `I`, `dv`, `u`, `Up`, `p`, `umin`, `ecfmin`, `s`
- Parallel setup: `np0`, `np1`

Boolean-valued options such as `vdt` and `ch` are emitted as explicit values,
so `simulateflow(...; vdt=false, ch=false)` is supported.

# Example Usage
```julia
simulateflow("u0.nc"; R=400, T=20, dT=1, outdir="data", label="u")
simulateflow("u0.nc"; T=0, vdt=false, ch=false, outdir="smoke", label="u_test")
```
"""
function simulateflow(initial_flowfield::AbstractString; kwargs...)
    verify_file(initial_flowfield)
    flags = _simulateflow_kwargs_to_flags(kwargs)
    run(`$(Channelflow_jll.simulateflow()) $flags $initial_flowfield`)
end

"""
    plotfield(flowfield::AbstractString; kwargs...)

Generates a set of slices and spectral properties of the flowfield at file path 
provided by `flowfield`, outputting Julia-readable ascii files.
See CloudAtlas.jl for an example of plotting these velocity fields.

This is a Julia wrapper for the Channelflow binary `plotfield`.

# Arguments
- `flowfield::AbstractString`: The file path to the input `FlowField`.

# Keyword Arguments
All command-line flags for the `plotfield` binary are passed to this function as keywords.

## Common Keyword Examples

### Output/Labeling:
- `label::String`: Output file stub, defaults to input field stub.
- `outdir::String`: Output directory (default: ".").

### Spectral Properties:
- `spectra::Bool`: Output Fourier and Chebyshev spectra.
- `showpad::Bool`: Include padded modes in spectra.
- `xavg::Bool`: Plot x-avg u,v,w.

### Profiles:
- `profiles::Bool`: Plot y-profiles of Fourier modes.
- `kx::Int`: kx for Fourier mode profile (default: 0).
- `kz::Int`: kz for Fourier mode profile (default: 0).
- `range::Bool`: Plot a range of Fourier modes.
- `kxmax::Int`: Max |kx| for range of Fourier mode y-profiles (default: 0).
- `kzmax::Int`: Max |kz| for range of Fourier mode y-profile (default: 0).

### Grid Stride/Values:
- `xstride::Int`: Output every xs-th gridpoint value (default: 1).
- `ystride::Int`: Output every ys-th gridpoint value (default: 1).
- `zstride::Int`: Output every zs-th gridpoint value (default: 1).
- `xval::Real`: Plot yz plane at x gridvalue closest to x (default: 0).
- `yval::Real`: Plot xz plane at y gridvalue closest to y (default: 0).
- `zval::Real`: Plot xy plane at z gridvalue closest to z (default: 0).

# Example Usage
```julia
# Output x-averaged profiles and spectra to the 'plots' directory
plotfield("u_re400.nc"; xavg=true, spectra=true, outdir="plots")

# Output a yz-plane slice near x=2.5 with a z-stride of 2
plotfield("u_re400.nc"; xval=2.5, zstride=2)
"""

function plotfield(flowfield::AbstractString; workdir::AbstractString=".", kwargs...)
    verify_file(flowfield)
    flags = kwargs_to_flags(kwargs)
    # The Channelflow binary is named 'plotfield'
    cmd = Cmd(`$(Channelflow_jll.plotfield()) $flags $(abspath(flowfield))`; dir=workdir)
    run(cmd)
end

"""
    L2op(field1::AbstractString, field2::AbstractString; kwargs...)

Computes L2-related operations between two flow fields, such as L2 distance
or L2 inner product.

This is a Julia wrapper for the Channelflow binary `L2op`.

# Arguments
- `field1::AbstractString`: The file path to the first input flow field.
- `field2::AbstractString`: The file path to the second input flow field.

# Keyword Arguments
- `dist::Bool`: Compute the L2 distance between the two fields.
- `ip::Bool`: Compute the L2 inner product of the two fields: L2IP(field1, field2).
- `n::Bool`: Normalize by norms of each field.
- `sx::Bool`: Shift by Lx/2 in the x-direction.
- `sz::Bool`: Shift by Lz/2 in the z-direction.
- `sd::Bool`: Save the difference field.

# Returns
- `Float64`: The computed L2 distance or inner product value.

# Example Usage
```julia
# Compute L2 distance between two fields
distance = L2op("u1.nc", "u2.nc"; dist=true)

# Compute normalized L2 inner product
inner_product = L2op("u1.nc", "u2.nc"; ip=true, n=true)

# Compute L2 distance with x-shift
distance = L2op("u1.nc", "u2.nc"; dist=true, sx=true)
```
"""
function L2op(field1::AbstractString, field2::AbstractString; workdir::AbstractString=".", kwargs...)
    verify_file(field1)
    verify_file(field2)
    flags = kwargs_to_flags(kwargs)

    # Capture the output from the L2op binary
    println("The flags are: $flags")
    println(`$flags $field1 $field2`)
    cmd = Cmd(`$(Channelflow_jll.L2op()) $flags $(abspath(field1)) $(abspath(field2))`; dir=workdir)
    output = read(cmd, String)

    # Parse the output to extract the numerical value
    # The output typically contains the result as a number
    result = parse(Float64, strip(output))

    return result
end

"""
	L2norm(field::AbstractString)

Computes the L2 Norm of a flow field.
"""
function L2norm(field::AbstractString)
    return sqrt(L2op(field, field; ip=true))
end

"""
    diffop(infield::AbstractString, outfield::AbstractString; kwargs...)

Applies a differential operation to a given flow field.

This is a Julia wrapper for the Channelflow binary `diffop`.

# Arguments
- `infield::AbstractString`: The file path to the input flow field.
- `outfield::AbstractString`: The file path to store the output field.

# Keyword Arguments

## Differential Operations:
- `ddx::Bool`: Apply d/dx.
- `ddy::Bool`: Apply d/dy.
- `ddz::Bool`: Apply d/dz.
- `grad::Bool`: Apply gradient.
- `lapl::Bool`: Apply laplacian.
- `curl::Bool`: Apply curl.
- `div::Bool`: Compute divergence.
- `nonl::Bool`: Compute Navier-Stokes nonlinearity.
- `e::Bool`: Compute energy operator.
- `Q::Bool`: Compute Q criterion.
- `norm::Bool`: Compute pointwise vector norm of field.
- `xavg::Bool`: Compute the streamwise average.

## Base Flow Options:
- `bf::String`: Set base flow to one of ["zero", "laminar", "linear", "parabolic", "suction"] (default: "laminar").
- `ub::String`: Input baseflow file of arbitrary U-baseflow (takes precedence over `-bf` option).
- `wb::String`: Input baseflow file of arbitrary W-baseflow (takes precedence over `-bf` option).
- `R::Real`: Pseudo-Reynolds number = 1/nu (default: 400).
- `nu::Real`: Kinematic viscosity (takes precedence over Reynolds if nonzero, default: 0).
- `mc::String`: Fix one of two flow constraints ["gradp", "bulkv"] (default: "gradp").
- `dPds::Real`: Magnitude of imposed pressure gradient along streamwise s (default: 0).
- `Ubulk::Real`: Magnitude of imposed bulk velocity (default: 0).
- `Uwall::Real`: Magnitude of imposed wall velocity, +/-Uwall at y = +/-h (default: 1).
- `theta::Real`: Angle of base flow relative to x-axis (default: 0).
- `Vs::Real`: Wall-normal suction velocity (default: 0).
- `Uf::Real`: Multiply baseflow by this factor before adding (default: 1).

# Example Usage
```julia
# Compute the gradient of a field
diffop("u.nc", "grad_u.nc"; grad=true)

# Compute the laplacian
diffop("u.nc", "lapl_u.nc"; lapl=true)

# Compute divergence
diffop("u.nc", "div_u.nc"; div=true)

# Compute Navier-Stokes nonlinearity with a laminar base flow at Re=400
diffop("u.nc", "nonl_u.nc"; nonl=true, bf="laminar", R=400)

# Compute streamwise average
diffop("u.nc", "u_xavg.nc"; xavg=true)
```
"""
function diffop(infield::AbstractString, outfield::AbstractString; workdir::AbstractString=".", kwargs...)
    verify_file(infield)
    flags = kwargs_to_flags(kwargs)
    cmd = Cmd(`$(Channelflow_jll.diffop()) $flags $(abspath(infield)) $(abspath(outfield))`; dir=workdir)
    run(cmd)
end

const _PERTURBFIELD_FLAG_MAP = Dict{Symbol, String}(
    :sd => "-sd",
    :seed => "--seed",
    :s => "-s",
    :smoothness => "--smoothness",
    :m => "-m",
    :magnitude => "--magnitude",
    :mf => "-mf",
    :meanflow => "--meanflow",
    :s1 => "-s1",
    :s1_symmetry => "--s1-symmetry",
    :s2 => "-s2",
    :s2_symmetry => "--s2-symmetry",
    :s3 => "-s3",
    :s3_symmetry => "--s3-symmetry",
)

function _perturbfield_flag_for_key(key::Symbol)
    haskey(_PERTURBFIELD_FLAG_MAP, key) && return _PERTURBFIELD_FLAG_MAP[key]
    throw(ArgumentError("Unknown perturbfield option keyword: $(key)"))
end

function _perturbfield_kwargs_to_flags(kwargs)
    flags = String[]
    for (key, value) in kwargs
        flag_name = _perturbfield_flag_for_key(key)
        if value isa Bool
            value && push!(flags, flag_name)
        else
            push!(flags, flag_name, string(value))
        end
    end
    return flags
end

"""
    perturbfield(infield::AbstractString, outfield::AbstractString; kwargs...)

Randomly perturbs `infield` and writes the perturbed flow field to `outfield`.
The perturbation is divergence-free and satisfies Dirichlet boundary conditions.

This is a Julia wrapper for the Channelflow binary `perturbfield`.

# Arguments
- `infield::AbstractString`: Input flow field filename.
- `outfield::AbstractString`: Output flow field filename.

# Keyword Arguments
- `sd` or `seed`: RNG seed (default 1).
- `s` or `smoothness`: smoothness parameter in (0, 1), default 0.4.
- `m` or `magnitude`: perturbation magnitude in (0, 1), default 0.2.
- `mf` or `meanflow`: perturb the mean.
- `s1` or `s1_symmetry`: enforce s1 symmetry.
- `s2` or `s2_symmetry`: enforce s2 symmetry.
- `s3` or `s3_symmetry`: enforce s3 symmetry.
"""
function perturbfield(infield::AbstractString, outfield::AbstractString; kwargs...)
    verify_file(infield)
    flags = _perturbfield_kwargs_to_flags(kwargs)
    run(`$(Channelflow_jll.perturbfield()) $flags $infield $outfield`)
end

"""
    addfields(outfield::AbstractString, fields_and_coeffs::Pair{<:Real,<:AbstractString}...; kwargs...)

Creates a linear combination of flowfields.

This is a Julia wrapper for the Channelflow binary `addfields` with the `-lc` flag.

# Arguments
- `outfield::AbstractString`: The file path to store the output field.
- `fields_and_coeffs::Pair{<:Real,<:AbstractString}...`: Pairs of coefficients and field paths,
  e.g., `c1 => "u1.nc", c2 => "u2.nc"` to compute `c1*u1 + c2*u2`.

# Keyword Arguments
- `lc::Bool`: Create a linear combination of flowfields (automatically set to true).

# Example Usage
```julia
# Create linear combination: 0.5*u1 + 0.3*u2 - 0.2*u3
addfields("u_combo.nc", 0.5 => "u1.nc", 0.3 => "u2.nc", -0.2 => "u3.nc")

# Simple addition: u1 + u2
addfields("u_sum.nc", 1.0 => "u1.nc", 1.0 => "u2.nc")
```
"""
function addfields(outfield::AbstractString, fields_and_coeffs::Pair{<:Real,<:AbstractString}...; workdir::AbstractString=".", kwargs...)
    # Verify all input fields exist
    for (coeff, field) in fields_and_coeffs
        verify_file(field)
    end

    flags = kwargs_to_flags(kwargs)

    # Build the command: addfields [flags] c0 u0 c1 u1 c2 u2 ... outfield
    cmd = Cmd(`$(Channelflow_jll.addfields()) -lc`; dir=workdir)

    # Add flags
    for flag in flags
        cmd = `$cmd $flag`
    end

    # Add coefficient-field pairs
    for (coeff, field) in fields_and_coeffs
        cmd = `$cmd $(string(coeff)) $(abspath(field))`
    end

    # Add output field
    cmd = `$cmd $(abspath(outfield))`

    run(cmd)
end

"""
    addbaseflow(infield::AbstractString, outfield::AbstractString; kwargs...)

Adds a baseflow to a given flowfield.

This is a Julia wrapper for the Channelflow binary `addfields` with the `-ab` flag.

# Arguments
- `infield::AbstractString`: The file path to the input flow field.
- `outfield::AbstractString`: The file path to store the output field.

# Keyword Arguments

## Base Flow Options:
- `bf::String`: Set base flow to one of ["zero", "laminar", "linear", "parabolic", "suction"] (default: "laminar").
- `ub::String`: Input baseflow file of arbitrary U-baseflow (takes precedence over `-bf` option).
- `wb::String`: Input baseflow file of arbitrary W-baseflow (takes precedence over `-bf` option).
- `R::Real`: Pseudo-Reynolds number = 1/nu (default: 400).
- `nu::Real`: Kinematic viscosity (takes precedence over Reynolds if nonzero, default: 0).
- `mc::String`: Fix one of two flow constraints ["gradp", "bulkv"] (default: "gradp").
- `dPds::Real`: Magnitude of imposed pressure gradient along streamwise s (default: 0).
- `Ubulk::Real`: Magnitude of imposed bulk velocity (default: 0).
- `Uwall::Real`: Magnitude of imposed wall velocity, +/-Uwall at y = +/-h (default: 1).
- `theta::Real`: Angle of base flow relative to x-axis (default: 0).
- `Vs::Real`: Wall-normal suction velocity (default: 0).
- `Uf::Real`: Multiply baseflow by this factor before adding (default: 1).

# Example Usage
```julia
# Add laminar baseflow at Re=250
addbaseflow("u.nc", "u_with_base.nc"; bf="laminar", R=250)

# Add parabolic baseflow
addbaseflow("u.nc", "u_with_base.nc"; bf="parabolic", R=400)
```
"""
function addbaseflow(infield::AbstractString, outfield::AbstractString; workdir::AbstractString=".", kwargs...)
    verify_file(infield)

    # Force the -ab flag
    flags = kwargs_to_flags(kwargs)

    cmd = Cmd(`$(Channelflow_jll.addfields()) -ab $flags $(abspath(infield)) $(abspath(outfield))`; dir=workdir)
    run(cmd)
end

"""
    findsymmetries(flowfield::AbstractString; kwargs...)

Finds the symmetries satisfied by a given flow field.

This is a Julia wrapper for the Channelflow binary `findsymmetries`.

# Arguments
- `flowfield::AbstractString`: The file path to the input flow field.

# Keyword Arguments
- `a::Bool`: Check antisymmetries as well.
- `v::Bool`: Print error of each checked symmetry (verbose mode).
- `nx::Int`: Check x-translations over set {0, nx-1}/nx * Lx (default: 4).
- `nz::Int`: Check z-translations over set {0, nz-1}/nz * Lz (default: 4).
- `e::Real`: Cut-off for symmetry error (default: 1e-06).

# Example Usage
```julia
# Find symmetries with default settings
findsymmetries("u.nc")

# Find symmetries and antisymmetries with verbose output
findsymmetries("u.nc"; a=true, v=true)

# Check finer grid of translations with tighter tolerance
findsymmetries("u.nc"; nx=8, nz=8, e=1e-08)
```
"""
function findsymmetries(flowfield::AbstractString; workdir::AbstractString=".", kwargs...)
    verify_file(flowfield)
    flags = kwargs_to_flags(kwargs)
    cmd = Cmd(`$(Channelflow_jll.findsymmetries()) $flags $(abspath(flowfield))`; dir=workdir)
    run(cmd)
end

end # end module
