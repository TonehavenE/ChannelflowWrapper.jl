"""
The ChannelflowWrapper.jl module is designed to provide convenient wrappers around commonly used Channelflow (the C++ library) functionality.
"""
module ChannelflowWrapper

export projectfield, field2coeff, coeff2field, changegrid, findsoln, continuesoln, plotfield, L2op, L2norm, diffop, addfields, addbaseflow, findsymmetries

import Channelflow_jll

include("utilities.jl")
"""
    field2coeff(ijklfile, source, output; kwargs...)

`field2coeff` takes a `source` (full velocity field) and projects it onto the
ODE basis defined by `ijklfile`, storing the resulting coefficient vector in `output`.

In addition to writing to the `output` file, this returns the vector of ODE coefficients.
This calls the Channelflow binary `projectfield` in its default mode.

# Arguments
- `ijklfile::AbstractString`: The file path to the file specifying the ijkl basis.
- `source::AbstractString`: The file path to the input velocity field to be projected.
- `output_base::AbstractString`: The file path to store the output coefficient vector. 
                                 `.asc` is appended to this if it doesn't already end with it.

# Keyword Arguments
- `nrm::Bool`: Normalize basis elements.
- `sb::Bool`: Output basis elements as flowfields.
- `sIP::Bool`: Output the inner product matrix.
- `pb::Bool`: Save slices of basis elements for plotting.
- `pn::Bool`: Print L2Norm(psi[n]), L2Norm(div(u)), etc.
- `o::String`: Directory for basis plots (default: "plots/").
- `A::String`: File path to load inner product matrix from.
"""
function field2coeff(ijklfile::AbstractString, source::AbstractString, output_base::AbstractString; kwargs...)
    verify_file(ijklfile)
    verify_file(source)
    output_target = occursin(".asc", output_base) ? output_base : output_base * ".asc"

    # Get the directory (where the final file should go) and the filename (what the binary needs)
    dir_target, fname_base = splitdir(output_target)

    # If no directory is specified, default to the current directory
    dir_target = isempty(dir_target) ? "." : dir_target

    # The Channelflow binary will write to the current directory ('.')
    output_working = fname_base

    intermediate_working = "x" * fname_base
    junk_working = "u" * fname_base

    flags = kwargs_to_flags(kwargs)

    # We must change to the target directory for the binary to work correctly if the path is relative.
    # However, since the binary only takes a basename, we'll run it in the current directory ('.') 
    # and use the basename for the output file.
    run(`$(Channelflow_jll.projectfield()) $flags $ijklfile $source $output_working`)

    # Check if the intermediate file (which has the coefficients) exists before trying to move it
    if isfile(intermediate_working)
        mv(intermediate_working, output_target; force=true)
    else
        error("Channelflow binary failed to produce the intermediate coefficient file: $intermediate_working")
    end

    # Remove the junk file generated by the binary, if it exists
    if isfile(junk_working)
        rm(junk_working)
    end

    return myreaddlm(output_target)
end

"""
    field2coeff(ijkl::AbstractMatrix, source, output; kwargs...)

Converts a field to the coefficient basis described by `ijkl`, where `ijkl` is a
Julia matrix rather than a file.
"""
function field2coeff(ijkl::AbstractMatrix, source::AbstractString, output::AbstractString; kwargs...)
    # This function uses temp files and calls the other method.
    ijkl2file(ijkl, "temp_ijkl.asc")
    coeffs = field2coeff("temp_ijkl.asc", source, output; kwargs...)
    rm("temp_ijkl.asc")
    return coeffs
end

"""
    coeff2field(source_coeffs, ijklfile, field_example, output; kwargs...)

Converts a file containing ODE coefficients (`source_coeffs`) back into a full
velocity field (`output`), using `field_example` as a grid template.

This calls the Channelflow binary `projectfield` with the `-x` flag.

# Arguments
- `source_coeffs::AbstractString`: File path to the vector of ODE coefficients.
- `ijklfile::AbstractString`: File path to the file specifying the ijkl basis.
- `field_example::AbstractString`: File path to a velocity field to use as a template
                                 (for grid size, box length, etc.).
- `output::AbstractString`: The file path to store the reconstructed output velocity field.

# Keyword Arguments
- All flags from `field2coeff` are also valid here, e.g., `nrm=true`
"""
function coeff2field(source_coeffs::AbstractString, ijklfile::AbstractString, field_example::AbstractString, output::AbstractString; kwargs...)
    verify_file(source_coeffs)
    verify_file(ijklfile)
    verify_file(field_example)


    output_target = occursin(".nc", output) ? output : output * ".nc"
    dir_target, fname_base = splitdir(output_target)
    dir_target = isempty(dir_target) ? "." : dir_target
    output_working = fname_base
    flags = kwargs_to_flags(kwargs)
    run(`$(Channelflow_jll.projectfield()) $flags -x $source_coeffs $ijklfile $field_example $output_working`)

    working_file = "u" * output_working

    if isfile(working_file)
        mv(working_file, output; force=true)
    else
        error("Channelflow binary failed to reconstruct the field. Expected file: $working_file")
    end
end

"""
    coeff2field(x, ijkl, field_example, output; kwargs...)

Converts a coefficient vector `x` and `ijkl` matrix directly, without needing to
store them in files. The result is stored in a file at `output`.
"""
function coeff2field(x::AbstractVector, ijkl::AbstractMatrix, field_example::AbstractString, output::AbstractString; kwargs...)
    # This function uses temp files and calls the other method.
    ijkl2file(ijkl, "temp_ijkl.asc")
    save(x, "temp_x.asc")

    coeff2field("temp_x.asc", "temp_ijkl.asc", field_example, output; kwargs...)

    rm("temp_ijkl.asc")
    rm("temp_x.asc")
end

"""
    projectfield(ijklfile, source, target; flags)

Legacy interface, defer to `field2coeff` ideally.
"""
function projectfield(ijklfile, source, target; kwargs...)
    field2coeff(ijklfile, source, target; kwargs=kwargs)
end

"""
    projectfield(source_coeffs, ijklfile, field_example, output; flags)

Legacy interface, defer to `coeff2field` ideally.
"""
function projectfield(source_coeffs, ijklfile, field_example, output; kwargs...)
    coeff2field(source_coeffs, ijklfile, field_example, output; kwargs=kwargs)
end


"""
    findsoln(guess_flowfield::AbstractString; kwargs...)

Takes the flowfield stored at filepath `guess_flowfield` and attempts to find a
solution (e.g., equilibrium, traveling wave, periodic orbit) using a Newton-Krylov solver.

This is a Julia wrapper for the Channelflow binary `findsoln`.

# Arguments
- `guess_flowfield::AbstractString`: The file path to the initial guess flow field.

# Keyword Arguments
All command-line flags for the `findsoln` binary are passed to this function as keywords.
- Boolean switches (e.g., `-eqb`) are passed as `eqb=true`.
- Value flags (e.g., `-R 350`) are passed as `R=350`.
- String flags (e.g., `-solver gmres`) are passed as `solver="gmres"`.

See the `findsoln --help` output for a complete list.

## Common Keyword Examples

### Search Type:
- `eqb::Bool`: Search for a fixed point (equilibrium) or traveling wave.
- `orb::Bool`: Search for a periodic or relative periodic orbit.
- `xrel::Bool`: Search for a relative solution (TW or RPO) with shift in x.
- `zrel::Bool`: Search for a relative solution (TW or RPO) with shift in z.

### System Parameters:
- `R::Real`: Pseudo-Reynolds number (default: 400).
- `nu::Real`: Kinematic viscosity (overrides `R`).
- `symms::String`: Path to a file listing symmetry generators.
- `sigma::String`: Path to a file for the `sigma` matrix (for TWs/RPOs).

### Numerical/Solver Parameters:
- `T::Real`: Final time of integration or period of map (default: 20).
- `dt::Real`: Timestep (default: 0.03125).
- `solver::String`: "gmres", "fgmres", "eigen", "bicgstab".
- `opt::String`: "hookstep", "linear", "none".
- `Nn::Int`: Max Newton steps (default: 20).
- `Ng::Int`: Max GMRES iterations (default: 500).
- `od::String`: Output directory (default: "./").

# Example Usage
```julia
# Find an equilibrium at Re=350 with symmetries from local file
findsoln("u_Re350.nc"; eqb=true, R=350, T=10, symms="./sxy_sz_txz.asc")

# Find a z-relative traveling wave
findsoln("u_guess.nc"; eqb=true, zrel=true, T=10, R=200, sigma="sigma_guess.asc", symms="sxytxz.asc")
```
"""
function findsoln(guess_flowfield::AbstractString; kwargs...)
    verify_file(guess_flowfield)
    flags = kwargs_to_flags(kwargs)
    run(`$(Channelflow_jll.findsoln()) $flags $guess_flowfield`)
end


"""
    changegrid(infield::AbstractString, outfield::AbstractString; kwargs...)

Interpolates a given flowfield onto a different grid.
This calls the Channelflow binary `changegrid`.

# Arguments
- `infield::AbstractString`: The file path to the input flow field.
- `outfield::AbstractString`: The file path to store the output (interpolated) flow field.

# Keyword Arguments
- `p::Bool` (default: true): Set padding modes to zero.
- `dv::Bool` (default: true): Fix divergence and Dirichlet BCs.
- `Nx::Int`: New number of x gridpoints.
- `Ny::Int`: New number of y gridpoints.
- `Nz::Int`: New number of z gridpoints.
- `a::Real`: New lower wall position.
- `b::Real`: New upper wall position.
- `al::Real` or `alpha::Real`: New alpha (2pi/Lx).
- `ga::Real` or `gamma::Real`: New gamma (2pi/Lz).
- `lx::Real`: New Lx = 2 pi lx.
- `lz::Real`: New Lz = 2 pi lz.
- `Lx::Real`: Streamwise (x) box length.
- `Lz::Real`: Spanwise (z) box length.
- `np0::Int` or `nproc0::Int`: Number of MPI-processes for transpose.
- `np1::Int` or `nproc1::Int`: Number of MPI-processes for one fft.
"""
function changegrid(infield::AbstractString, outfield::AbstractString; kwargs...)
    verify_file(infield)
    flags = kwargs_to_flags(kwargs)
    run(`$(Channelflow_jll.changegrid()) $flags $infield $outfield`)
end

"""
    continuesoln(initial_flowfield::AbstractString; kwargs...)

Performs a parametric continuation of an invariant solution (e.g., equilibrium,
traveling wave, or periodic orbit) starting from an initial guess.

This is a Julia wrapper for the Channelflow binary `continuesoln`.

# Arguments
- `initial_flowfield::AbstractString`: The file path to the initial solution
  (e.g., "ueqd_Re400.nc") from which to start the continuation.

# Keyword Arguments
All command-line flags for the `continuesoln` binary are passed as keywords.
- Boolean switches (e.g., `-eqb`) are passed as `eqb=true`.
- Value flags (e.g., `-R 400`) are passed as `R=400`.
- String flags (e.g., `-cont Re`) are passed as `cont="Re"`.

See `continuesoln --help` for the full list of ~70 options.

## Key Keyword Arguments
- `cont::String`: **(Required)** The continuation parameter. One of:
  "Re", "P", "Ub", "Uw", "ReP", "Theta", "ThLx", "ThLz", "Lx", "Lz",
  "Aspect", "Diag", "Lt", "Vs", "ReVs", "H", "HVs", "Rot".
- `dmu::Real`: The initial relative increment for the continuation parameter
  (default: 0.0001).
- `eqb::Bool` or `orb::Bool`: Specify the solution type (equilibrium or orbit).
- `R::Real`: The initial pseudo-Reynolds number (default: 400).
- `symms::String`: Path to a file listing symmetry generators.
- `al::Bool`: Use arclength continuation (default: false).
- `ds0::Real`: Initial arclength increment (if `al=true`).
- `targ::Bool`: Abort when the target value `targMu` is reached.
- `targMu::Real`: The target value for the continuation parameter.
- `od::String`: Output directory (default: "./").

# Example Usage
```julia
# Continue an equilibrium in Reynolds number
continuesoln("ueqd_Re400.nc";
    cont="Re",
    eqb=true,
    R=400,
    T=19,
    dmu=-0.01,
    symms="sxy_sztx.asc"
)
```
"""
function continuesoln(initial_flowfield::AbstractString; kwargs...)
    verify_file(initial_flowfield)
    flags = kwargs_to_flags(kwargs)
    run(`$(Channelflow_jll.continuesoln()) $flags $initial_flowfield`)
end

"""
    plotfield(flowfield::AbstractString; kwargs...)

Generates a set of slices and spectral properties of the flowfield at file path 
provided by `flowfield`, outputting Julia-readable ascii files.
See CloudAtlas.jl for an example of plotting these velocity fields.

This is a Julia wrapper for the Channelflow binary `plotfield`.

# Arguments
- `flowfield::AbstractString`: The file path to the input `FlowField`.

# Keyword Arguments
All command-line flags for the `plotfield` binary are passed to this function as keywords.

## Common Keyword Examples

### Output/Labeling:
- `label::String`: Output file stub, defaults to input field stub.
- `outdir::String`: Output directory (default: ".").

### Spectral Properties:
- `spectra::Bool`: Output Fourier and Chebyshev spectra.
- `showpad::Bool`: Include padded modes in spectra.
- `xavg::Bool`: Plot x-avg u,v,w.

### Profiles:
- `profiles::Bool`: Plot y-profiles of Fourier modes.
- `kx::Int`: kx for Fourier mode profile (default: 0).
- `kz::Int`: kz for Fourier mode profile (default: 0).
- `range::Bool`: Plot a range of Fourier modes.
- `kxmax::Int`: Max |kx| for range of Fourier mode y-profiles (default: 0).
- `kzmax::Int`: Max |kz| for range of Fourier mode y-profile (default: 0).

### Grid Stride/Values:
- `xstride::Int`: Output every xs-th gridpoint value (default: 1).
- `ystride::Int`: Output every ys-th gridpoint value (default: 1).
- `zstride::Int`: Output every zs-th gridpoint value (default: 1).
- `xval::Real`: Plot yz plane at x gridvalue closest to x (default: 0).
- `yval::Real`: Plot xz plane at y gridvalue closest to y (default: 0).
- `zval::Real`: Plot xy plane at z gridvalue closest to z (default: 0).

# Example Usage
```julia
# Output x-averaged profiles and spectra to the 'plots' directory
plotfield("u_re400.nc"; xavg=true, spectra=true, outdir="plots")

# Output a yz-plane slice near x=2.5 with a z-stride of 2
plotfield("u_re400.nc"; xval=2.5, zstride=2)
"""

function plotfield(flowfield::AbstractString; kwargs...)
    verify_file(flowfield)
    flags = kwargs_to_flags(kwargs)
    # The Channelflow binary is named 'plotfield'
    run(`$(Channelflow_jll.plotfield()) $flags $flowfield`)
end

"""
    L2op(field1::AbstractString, field2::AbstractString; kwargs...)

Computes L2-related operations between two flow fields, such as L2 distance
or L2 inner product.

This is a Julia wrapper for the Channelflow binary `L2op`.

# Arguments
- `field1::AbstractString`: The file path to the first input flow field.
- `field2::AbstractString`: The file path to the second input flow field.

# Keyword Arguments
- `dist::Bool`: Compute the L2 distance between the two fields.
- `ip::Bool`: Compute the L2 inner product of the two fields: L2IP(field1, field2).
- `n::Bool`: Normalize by norms of each field.
- `sx::Bool`: Shift by Lx/2 in the x-direction.
- `sz::Bool`: Shift by Lz/2 in the z-direction.
- `sd::Bool`: Save the difference field.

# Returns
- `Float64`: The computed L2 distance or inner product value.

# Example Usage
```julia
# Compute L2 distance between two fields
distance = L2op("u1.nc", "u2.nc"; dist=true)

# Compute normalized L2 inner product
inner_product = L2op("u1.nc", "u2.nc"; ip=true, n=true)

# Compute L2 distance with x-shift
distance = L2op("u1.nc", "u2.nc"; dist=true, sx=true)
```
"""
function L2op(field1::AbstractString, field2::AbstractString; kwargs...)
    verify_file(field1)
    verify_file(field2)
    flags = kwargs_to_flags(kwargs)

    # Capture the output from the L2op binary
    println("The flags are: $flags")
    println(`$flags $field1 $field2`)
    output = read(`$(Channelflow_jll.L2op()) $flags $field1 $field2`, String)

    # Parse the output to extract the numerical value
    # The output typically contains the result as a number
    result = parse(Float64, strip(output))

    return result
end

"""
	L2norm(field::AbstractString)

Computes the L2 Norm of a flow field.
"""
function L2norm(field::AbstractString)
    return sqrt(L2op(field, field; ip=true))
end

"""
    diffop(infield::AbstractString, outfield::AbstractString; kwargs...)

Applies a differential operation to a given flow field.

This is a Julia wrapper for the Channelflow binary `diffop`.

# Arguments
- `infield::AbstractString`: The file path to the input flow field.
- `outfield::AbstractString`: The file path to store the output field.

# Keyword Arguments

## Differential Operations:
- `ddx::Bool`: Apply d/dx.
- `ddy::Bool`: Apply d/dy.
- `ddz::Bool`: Apply d/dz.
- `grad::Bool`: Apply gradient.
- `lapl::Bool`: Apply laplacian.
- `curl::Bool`: Apply curl.
- `div::Bool`: Compute divergence.
- `nonl::Bool`: Compute Navier-Stokes nonlinearity.
- `e::Bool`: Compute energy operator.
- `Q::Bool`: Compute Q criterion.
- `norm::Bool`: Compute pointwise vector norm of field.
- `xavg::Bool`: Compute the streamwise average.

## Base Flow Options:
- `bf::String`: Set base flow to one of ["zero", "laminar", "linear", "parabolic", "suction"] (default: "laminar").
- `ub::String`: Input baseflow file of arbitrary U-baseflow (takes precedence over `-bf` option).
- `wb::String`: Input baseflow file of arbitrary W-baseflow (takes precedence over `-bf` option).
- `R::Real`: Pseudo-Reynolds number = 1/nu (default: 400).
- `nu::Real`: Kinematic viscosity (takes precedence over Reynolds if nonzero, default: 0).
- `mc::String`: Fix one of two flow constraints ["gradp", "bulkv"] (default: "gradp").
- `dPds::Real`: Magnitude of imposed pressure gradient along streamwise s (default: 0).
- `Ubulk::Real`: Magnitude of imposed bulk velocity (default: 0).
- `Uwall::Real`: Magnitude of imposed wall velocity, +/-Uwall at y = +/-h (default: 1).
- `theta::Real`: Angle of base flow relative to x-axis (default: 0).
- `Vs::Real`: Wall-normal suction velocity (default: 0).
- `Uf::Real`: Multiply baseflow by this factor before adding (default: 1).

# Example Usage
```julia
# Compute the gradient of a field
diffop("u.nc", "grad_u.nc"; grad=true)

# Compute the laplacian
diffop("u.nc", "lapl_u.nc"; lapl=true)

# Compute divergence
diffop("u.nc", "div_u.nc"; div=true)

# Compute Navier-Stokes nonlinearity with a laminar base flow at Re=400
diffop("u.nc", "nonl_u.nc"; nonl=true, bf="laminar", R=400)

# Compute streamwise average
diffop("u.nc", "u_xavg.nc"; xavg=true)
```
"""
function diffop(infield::AbstractString, outfield::AbstractString; kwargs...)
    verify_file(infield)
    flags = kwargs_to_flags(kwargs)
    run(`$(Channelflow_jll.diffop()) $flags $infield $outfield`)
end

"""
    addfields(outfield::AbstractString, fields_and_coeffs::Pair{<:Real,<:AbstractString}...; kwargs...)

Creates a linear combination of flowfields.

This is a Julia wrapper for the Channelflow binary `addfields` with the `-lc` flag.

# Arguments
- `outfield::AbstractString`: The file path to store the output field.
- `fields_and_coeffs::Pair{<:Real,<:AbstractString}...`: Pairs of coefficients and field paths,
  e.g., `c1 => "u1.nc", c2 => "u2.nc"` to compute `c1*u1 + c2*u2`.

# Keyword Arguments
- `lc::Bool`: Create a linear combination of flowfields (automatically set to true).

# Example Usage
```julia
# Create linear combination: 0.5*u1 + 0.3*u2 - 0.2*u3
addfields("u_combo.nc", 0.5 => "u1.nc", 0.3 => "u2.nc", -0.2 => "u3.nc")

# Simple addition: u1 + u2
addfields("u_sum.nc", 1.0 => "u1.nc", 1.0 => "u2.nc")
```
"""
function addfields(outfield::AbstractString, fields_and_coeffs::Pair{<:Real,<:AbstractString}...; kwargs...)
    # Verify all input fields exist
    for (coeff, field) in fields_and_coeffs
        verify_file(field)
    end

    flags = kwargs_to_flags(kwargs)

    # Build the command: addfields [flags] c0 u0 c1 u1 c2 u2 ... outfield
    cmd = `$(Channelflow_jll.addfields()) -lc`

    # Add flags
    for flag in flags
        cmd = `$cmd $flag`
    end

    # Add coefficient-field pairs
    for (coeff, field) in fields_and_coeffs
        cmd = `$cmd $(string(coeff)) $field`
    end

    # Add output field
    cmd = `$cmd $outfield`

    run(cmd)
end

"""
    addbaseflow(infield::AbstractString, outfield::AbstractString; kwargs...)

Adds a baseflow to a given flowfield.

This is a Julia wrapper for the Channelflow binary `addfields` with the `-ab` flag.

# Arguments
- `infield::AbstractString`: The file path to the input flow field.
- `outfield::AbstractString`: The file path to store the output field.

# Keyword Arguments

## Base Flow Options:
- `bf::String`: Set base flow to one of ["zero", "laminar", "linear", "parabolic", "suction"] (default: "laminar").
- `ub::String`: Input baseflow file of arbitrary U-baseflow (takes precedence over `-bf` option).
- `wb::String`: Input baseflow file of arbitrary W-baseflow (takes precedence over `-bf` option).
- `R::Real`: Pseudo-Reynolds number = 1/nu (default: 400).
- `nu::Real`: Kinematic viscosity (takes precedence over Reynolds if nonzero, default: 0).
- `mc::String`: Fix one of two flow constraints ["gradp", "bulkv"] (default: "gradp").
- `dPds::Real`: Magnitude of imposed pressure gradient along streamwise s (default: 0).
- `Ubulk::Real`: Magnitude of imposed bulk velocity (default: 0).
- `Uwall::Real`: Magnitude of imposed wall velocity, +/-Uwall at y = +/-h (default: 1).
- `theta::Real`: Angle of base flow relative to x-axis (default: 0).
- `Vs::Real`: Wall-normal suction velocity (default: 0).
- `Uf::Real`: Multiply baseflow by this factor before adding (default: 1).

# Example Usage
```julia
# Add laminar baseflow at Re=250
addbaseflow("u.nc", "u_with_base.nc"; bf="laminar", R=250)

# Add parabolic baseflow
addbaseflow("u.nc", "u_with_base.nc"; bf="parabolic", R=400)
```
"""
function addbaseflow(infield::AbstractString, outfield::AbstractString; kwargs...)
    verify_file(infield)

    # Force the -ab flag
    flags = kwargs_to_flags(kwargs)

    run(`$(Channelflow_jll.addfields()) -ab $flags $infield $outfield`)
end

"""
    findsymmetries(flowfield::AbstractString; kwargs...)

Finds the symmetries satisfied by a given flow field.

This is a Julia wrapper for the Channelflow binary `findsymmetries`.

# Arguments
- `flowfield::AbstractString`: The file path to the input flow field.

# Keyword Arguments
- `a::Bool`: Check antisymmetries as well.
- `v::Bool`: Print error of each checked symmetry (verbose mode).
- `nx::Int`: Check x-translations over set {0, nx-1}/nx * Lx (default: 4).
- `nz::Int`: Check z-translations over set {0, nz-1}/nz * Lz (default: 4).
- `e::Real`: Cut-off for symmetry error (default: 1e-06).

# Example Usage
```julia
# Find symmetries with default settings
findsymmetries("u.nc")

# Find symmetries and antisymmetries with verbose output
findsymmetries("u.nc"; a=true, v=true)

# Check finer grid of translations with tighter tolerance
findsymmetries("u.nc"; nx=8, nz=8, e=1e-08)
```
"""
function findsymmetries(flowfield::AbstractString; kwargs...)
    verify_file(flowfield)
    flags = kwargs_to_flags(kwargs)
    run(`$(Channelflow_jll.findsymmetries()) $flags $flowfield`)
end

end # end module
